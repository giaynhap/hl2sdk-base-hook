/* Plugin Template generated by Pawn Studio */

#pragma semicolon 1
#include <cstrike>
#include <sourcemod>
#include <sdktools>
#include <sdktools>
#include <sdkhooks>
#include <GNHook>
public Plugin:myinfo = 
{
	name = "TeamDM - Counter Strike Source",
	author = "GiayNhap",
	description = "<- Description ->",
	version = "1.0",
	url = "<- URL ->"
}
new OffAW = -1;
new bool:g_roundStarted;
new g_playerClass[MAXPLAYERS + 1];
new g_Respawn[MAXPLAYERS+1];
new Float:g_respawnTime = 5.0;
new bool:g_byHook[MAXPLAYERS+1];
new bool:gCanBuy[MAXPLAYERS+1];
new bool:gProtectTime[MAXPLAYERS+1];
new gProtectHanld[MAXPLAYERS+1];

 int g_score = 100;
 int g_ctScore = 0;
 int g_terScore = 0;

public void OnPluginStart()
{
  OffAW = FindSendPropInfo("CBasePlayer", "m_hActiveWeapon");
  GNDM_Hook();
}

 GNDM_Hook()
{
RegConsoleCmd("joinclass", Event_JoinClass);

HookEvent("player_death", Event_PlayerDeath);
HookEvent("round_end", Event_RoundEnd, EventHookMode_PostNoCopy);
HookEvent("round_start", Event_RoundStart, EventHookMode_PostNoCopy);
HookEvent("player_team", Event_PlayerTeam);
HookEvent("player_spawn", Event_PlayerSpawn);


 g_roundStarted = true;
for (new i = 1; i <= MaxClients ; i++) {
	g_playerClass[i] = 1;
	gProtectTime[i] = true;
	g_byHook[i] = false;
	if ( CanClientSpawn(i) ) {
		StartRespawnTimer(i);
	}
}

}

StartRespawnTimer(client) {
 
    g_Respawn[client] =  CreateTimer(5.0, ExecRespawn, client);
   
}

CanClientSpawn(client) {
    return IsClientInGame(client) && (GetClientTeam(client) > 1) && (!IsPlayerAlive(client));
}


public OnMapStart() 
{
	for (new i = 1; i <= MaxClients ; i++) {
		g_playerClass[i] = 1;
		gProtectTime[i] = true;
		g_byHook[i] = false;
		 
	}

   removeC4AndHostage();
}  

HookSDK(client)	{		
	
	
	if (IsClientInGame(client) ) {
		
			if(!g_byHook[client]) {
				g_byHook[client] = true;
				
			SDKHookEx(client,SDKHook_PostThink, SDKHook_hcPostThinkSetBuyZone);
			SDKHook(client, SDKHook_OnTakeDamage, SDKHook_hcOnTakeDamage);
			SDKHook(client, SDKHook_WeaponSwitchPost, SDKHook_hcOnClientWeaponSwitchPost);     
			SDKHook(client, SDKHook_WeaponDrop, SDKHook_hcOnClientWeaponDrop);
		//	SDKHook(client, SDKHook_TraceAttack,SDKHook_hcTraceAttack);
		//	SDKHook(client, SDKHook_TraceAttackPost,SDKHook_hcTraceAttackPost);
		}
	}
}

public Action:CS_OnGetWeaponPrice(client, const String:weapon[], &price) 
{ 
    
    price = 1; 
    return Plugin_Changed; 
}  

public Action:SDKHook_hcOnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype, &weapon, Float:damageForce[3], Float:damagePosition[3]){
		
		if (victim > 0 || victim <= MAXPLAYERS)
		{
			if (gProtectTime[victim]){
			
				PrintToConsoleAll("ProtectTime");
				 damage = 0.0; 
					return Plugin_Handled; 
			}
		}
        return Plugin_Continue;

}

public Action:SDKHook_hcOnClientWeaponDrop(client, wpnent){
	
	
	 CreateTimer(10.0, Timer_DropWeapon, wpnent);
	return Plugin_Continue;
}

public Action:Timer_DropWeapon(Handle:timer, any:weapon) {
	
	if (IsValidEdict(weapon)&&GetEntPropEnt(weapon, Prop_Send, "m_hOwnerEntity") == -1)
	{
	//	decl String:weapon_name[32];
	//	GetEdictClassname(weapon, weapon_name, sizeof(weapon_name));
		//PrintToChat(client, "You drop this weapon: %s", weapon_name);
		RemoveEdict(weapon);
	}
	
}

public Action:SDKHook_hcOnClientWeaponSwitchPost(client, wpnid)
{
	//		new ent =  GetEntPropEnt(client, Prop_Send, "m_hViewModel");
    // SetEntityRenderMode( ent, RENDER_GLOW);
	//	 SetEntityRenderColor( ent, 255, 0,0, 255);
}


public Action:SDKHook_hcTraceAttack(victim, &attacker, &inflictor, &Float:damage, &damagetype, &ammotype, hitbox, hitgroup)
{
 return Plugin_Continue;
}


public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
 
		if (buttons & IN_ATTACK || buttons & IN_ATTACK2)
		{
			new ent = GetEntDataEnt2(client, OffAW);
			if(ent != -1)
			{
				 gCanBuy[client] = false;
				 SetEntProp(client, Prop_Send, "m_bInBuyZone", 0);
			}
			 
		}
 
	return Plugin_Continue;
}

public SDKHook_hcTraceAttackPost(victim, attacker, inflictor, Float:damage, damagetype, ammotype, hitbox, hitgroup)
{
 return Plugin_Continue;
}


public SDKHook_hcPostThinkSetBuyZone(client) {
	if(gCanBuy[client]) SetEntProp(client, Prop_Send, "m_bInBuyZone", 1);
	else SetEntProp(client, Prop_Send, "m_bInBuyZone", 0);
}

removeC4AndHostage()
{
	 PrintToServer("%s", "RemoveC4andHostage");
	// remove Boom
	for (new i = 1; i <= MaxClients; i++)
	{
		if (IsClientInGame(i) && IsPlayerAlive(i))
		{
			new iWeapon = GetPlayerWeaponSlot(i, 4);

			if (iWeapon != -1 && IsValidEdict(iWeapon))
			{
				decl String:szClassName[64];
				GetEdictClassname(iWeapon, szClassName, sizeof(szClassName));

				if (StrEqual(szClassName, "weapon_c4"))
				{
					RemovePlayerItem(i, iWeapon);
					RemoveEdict(iWeapon);
				}
			}
		}
	}
	
	// remove Hostage hostage_entity
	
    decl String:_sBuffer[64];
    for(new i = MaxClients + 1; i <= 2047; i++)
    {
        if(!IsValidEdict(i))
            continue;

        GetEdictClassname(i, _sBuffer, sizeof(_sBuffer));
        if(StrContains("func_bomb_target|func_hostage_rescue|c4|hostage_entity|info_hostage_rescue", _sBuffer) >= 0)
            RemoveEdict(i);
		 
				 
    }

}
public Event_PlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	// if( GetEntProp(client, Prop_Send, "m_bIsControllingBot") != 1) { //Check if it's bot takeover or real spawn
		HookSDK(client);
	// }
	
	
	
	gCanBuy[client] = true;
	gProtectTime[client] = true;
	if (gProtectTime[client]){
		 SetEntityRenderMode(client, RENDER_GLOW);
		 SetEntityRenderColor(client, 255, 0,0, 255);
		 SetEntProp(client, Prop_Send, "m_iAccount", 16000);  
		 gProtectHanld[client] = CreateTimer(5.0, Timer_ProtectRespawn, client,  TIMER_FLAG_NO_MAPCHANGE);
	 
	}
	
}


public Action:Event_JoinClass(client, args)
{
 
    g_playerClass[client] = 1;
    StartRespawnTimer(client);
	
    return Plugin_Continue;
}


public Action:Event_RoundEnd(Handle:event,const String:name[],bool:dontBroadcast)
{
    g_roundStarted = false;
}

public Action:Event_RoundStart(Handle:event,const String:name[],bool:dontBroadcast)
{
    g_roundStarted = true;
	ServerCommand("mp_roundtime 15000"); 
	ServerCommand("mp_buytime 999999"); 
	ServerCommand("mp_ignore_round_win_conditions 1"); 
	ServerCommand("sv_cheats 1");
	ServerCommand("bot_stop 1");
	PrintToServer("%s", "GNDM-ROUNDSTART");
	updateTeamScore(g_score,g_ctScore,g_terScore);
}

public Action:Event_PlayerDeath(Handle:event,const String:name[],bool:dontBroadcast)
{
    new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
	new user_team = GetClientTeam(client);
	new attacker_team = GetClientTeam(attacker);
	if (user_team!=attacker_team)
	{
		if (attacker_team==3)
			g_ctScore++;
		else
			g_terScore++;
	}
	updateTeamScore(g_score,g_ctScore,g_terScore);
    StartRespawnTimer(client);
}

public Event_PlayerTeam(Handle:event, const String:name[], bool:dontBroadcast)
{
	new newTeam = GetEventInt(event, "team");
    new client = GetClientOfUserId(GetEventInt(event, "userid"));
    
    if ( !client || (newTeam < 2) )
    {
        return;
    }
    
    if ( IsFakeClient(client) )
    {
        g_playerClass[client] = 1;
       
        g_Respawn[client] = CreateTimer(g_respawnTime, ExecRespawn, client);
    }
    else
    {
        g_playerClass[client] = 0;
    }
}

public Action:Timer_ProtectRespawn(Handle:timer, any:client) {
	gProtectTime[client] = false;
	if ( IsClientInGame(client)){
		SetEntityRenderMode(client, RENDER_NORMAL);
		SetEntityRenderColor(client, 255,255,255, 255);
	}
}
public Action:ExecRespawn(Handle:timer, any:client)
{
    if ( client && CanClientSpawn(client) && g_playerClass[client] )
    {
        if ( !g_roundStarted )
        {
          
        }
        else
        {
			
            CS_RespawnPlayer(client);
        }
    }    
    return Plugin_Stop;
}

